% Generated by roxygen2 (4.0.1): do not edit by hand
\name{checkpoint}
\alias{checkpoint}
\title{Set checkpoint date, downloads required packages from MRAN and sets libPath as well as CRAN mirror.}
\usage{
checkpoint(snapshotDate = NULL, repo = getwd(), persistent = FALSE,
  verbose = TRUE)
}
\arguments{
\item{snapshotDate}{(date) Required. Date of snapshot to use. E.g. "2014-06-20". If left blank, you
will be supplied with options.}

\item{repo}{A repository path. This is the path to the root of your RRT repository. Defaults to current working directory current working directory via /code{/link{getwd}}.}

\item{verbose}{(logical) Whether to print messages or not (Default: TRUE).}
}
\value{
NULL. See the \code{details} section for side effects.
}
\description{
The aim of the MRAN server combined with the RRT package is to serve as a "CRAN time machine".  Once a day, MRAN mirrors all of CRAN and saves a snapshot.  This allows you to install packages from a snapshot, and go back in time to this date, by installing packages as they were at that snapshot date.
}
\details{
When you create a checkpoint, the following happens:

\itemize{
\item{Create a snapshot folder to download packages. This library folder is at \code{~/.rrt}}
\item{Set options for your CRAN mirror to point to a MRAN snapshot, i.e. modify \code{options(repos)}}
\item{Scan your project folder for all packages used and install these using \code{\link[utils]{download.packages}}}
\item{Create a file \code{.Rprofile}} to initialise your library path to the snapshot library path
}
}
\examples{
# tests for initialize

repo_root <- file.path(tempdir(), "rrttemp")

snap_date <- "2014-09-08"

checkpoint(snap_date, repo = repo_root)

# Check that CRAN mirror is set to MRAN snapshot
getOption("repos")

# Check that library path is set to ~/.rrt
.libPaths()
installed.packages()

# Write dummy code file to repo
cat("library(MASS)", "library(XML)",
    sep="\\n",
    file = file.path(repo_root, "code.R")
)


checkpoint(snap_date, repo = repo_root)
installed.packages()

# cleanup
unlink(repo_root, recursive=TRUE)

}

